\chapter{Introduction}
Bio-inspired optimization algorithms are used to find good (preferably best) solutions to a given optimization problem. They mimic the behavior of biological agents. A prominent example is the genetic algorithm (GA) \cite{sivanandam2008genetic} that uses a simplified model of natural evolution to improve the solutions towards an optimum. Another example is the particle swarm optimization (PSO) \cite{kennedy2010particle}, which is based on the movement of bird flocks.

Most optimization problems are NP-hard. It is not feasible to explore all possible solutions, since this would simply take too much time. Bio-inspired optimization algorithms can't change this fundamental issue, however, for many problems their approximation techniques provide solutions which are ``good enough'' in an acceptable time.

Parallelization techniques can be applied to further reduce computational time by parallelizing a single sample evaluation or by evaluating more samples in parallel. There are different approaches to parallelization on current computer architectures. Some of them focus on the exploitation of processing units that are local to a given machine like SIMD\footnote{\url{https://en.wikipedia.org/wiki/SIMD} last access: 07.01.2015}, multi core\footnote{\url{https://en.wikipedia.org/wiki/Multi-core_processor} last access: 07.01.2015} or specialized hardware (GPU\footnote{\url{https://en.wikipedia.org/wiki/Graphics_processing_unit} last access: 07.01.2015}, FPGA\footnote{\url{https://en.wikipedia.org/wiki/Field-programmable_gate_array} last access: 07.01.2015}, ASIC\footnote{\url{https://en.wikipedia.org/wiki/Application-specific_integrated_circuit} last access: 07.01.2015}). Local approaches work well in many cases, but the increase of computational power is limited by the resources of a single computer.

Further performance increases can be achieved by distributing the work among several computers, forming a cluster. The downside of this approach is the increased overall complexity. On the one side, hardware components are unreliable and may fail (e.g. hard drives), which must be detected and handled in an appropriate way. On the other side, the computers need to communicate with each other through the network to distribute work tasks and data.

Apache Hadoop\footnote{\url{https://hadoop.apache.org/} last access: 07.01.2015} is an open source software project that provides management tools for clusters and libraries to build distributed applications. It is often referred to as an operating system for clusters. It assumes that cluster hardware is inherently unreliable and provides mechanisms to automatically detect and handle failures. This enables distributed applications to focus on the implementation rather than on cluster management concerns. Hadoop also provides the mechanisms to start, stop and monitor distributed applications and automatically restart them if needed.

Hadoop versions prior to 2.0 were restricted to the MapReduce \cite{dean2008mapreduce} computational model. This restriction made it difficult to implement, e.g., iterative algorithms, like the bio-inspired optimization techniques. With the release of Hadoop 2.0 the resource management implementation has been changed to YARN \cite{vavilapalli2013apache} which makes no assumptions about the application being executed .

One drawback of YARN, however, is the missing support for application specific communication. This restriction comes by design, as YARNs purpose is to manage the cluster, its resources and the running applications.

Different software projects try to improve Hadoop and solve the communication issue. Apache Storm\footnote{\url{https://storm.apache.org/} last access: 01.10.2014} implements a stream processing model on top of Hadoop, where cluster nodes are connected to form a graph through which the data flows. Data processing and transformation is performed on the nodes. Apache Spark\footnote{\url{https://spark.apache.org/} last access: 01.10.2014} supports both the stream model and a batch processing model on top of Hadoop. In addition, it provides a distributed in-memory store \cite{zaharia2012resilient}.

Biohadoop\footnote{\url{https://github.com/gappc/biohadoop/} last access: 15.12.2014} is another project whose goal is to simplify the implementation of distributed applications on top of Hadoop. It was developed during this thesis and works based on the master-worker pattern. Biohadoop offers an abstract communication mechanism that makes it easy to distribute work items from the master node to any number of worker nodes. The focus on the master-worker pattern makes it more lightweight than the previous solutions mentioned above, provided that the problem fits into the master-worker pattern.

Biohadoop differs from other projects such as Mahout\footnote{\url{https://mahout.apache.org/} last access: 02.02.2015} in that it does not depend on MapReduce. MapReduce has shown great performance for data intensive applications, but performs poor for iterative problems. Special techniques must be used to overcome its limitations, like result caching \cite{bu2010haloop} or long running map and reduce stages \cite{ekanayake2010twister}. This is not necessary using Biohadoop. It runs without sophisticated tricks by using the provided capabilities of YARN. To the authors best knowledge, Biohadoop is the first framework for the implementation of bio-inspired optimization algorithms on Hadoop that natively uses YARN on doesn't rely on MapReduce.

In this thesis, Biohadoop is introduced and its usefulness is demonstrated with two bio-inspired optimization techniques. The thesis provides additional information about Apache Oozie\footnote{\url{https://oozie.apache.org/} last access: 01.10.2014} (a Hadoop workflow tool) and how it was extended to support Biohadoop.

The rest of the document is organized as follows: chapter \ref{chap:bioalgorithms} provides an introduction to bio-inspired optimization algorithms as well as an overview of two common representatives: GA and PSO. Chapter \ref{chap:hadoop} provides information about Hadoop and Oozie needed to understand the functionality of Biohadoop. Chapter \ref{chap:impl} explains Biohadoops architecture and the modifications implemented for Oozie (section \ref{chap:impl:oozie}). Chapter \ref{chap:evaluation} evaluates the performance of Biohadoop using two different implementations of a GA. The conclusions in chapter \ref{chap:conclusions} summarize the master thesis and the obtained results.